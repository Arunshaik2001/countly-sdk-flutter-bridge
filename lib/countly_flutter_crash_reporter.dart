import 'dart:async';

import 'package:flutter/services.dart';
import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:stack_trace/stack_trace.dart';
import 'countly_flutter.dart';
class CountlyFlutterCrashReporter {
  static final CountlyFlutterCrashReporter instance = CountlyFlutterCrashReporter();
  /// Set to true to have errors sent to Countly while in debug mode. By
  /// default this is true.
  bool enableInDevMode = true;
  bool enableCrashReportingFlag = false;

  static const MethodChannel _channel =
  const MethodChannel('countly_flutter');

  Future<String> enableCrashReporting([bool enableInDev]) async {
    enableInDevMode = enableInDev ?? true;
    FlutterError.onError = recordFlutterError;
    List <String> args = [];
    enableCrashReportingFlag = true;
    Countly.log(args.toString());
    final String result = await _channel.invokeMethod('enableCrashReporting', <String, dynamic>{
      'data': json.encode(args)
    });
    Countly.log(result);
    return result;
  }
  
  Future<String> logException(String exception,bool nonfatal, List<Map<String, String>> stackTraceElements, String information) async {
    List <String> args = [];
    if(exception == null) {
      String error = "logException, provided exception was null, returning";
      Countly.log(error);
      return "Error : $error";
    }
    args.add(exception);
    args.add(nonfatal.toString());
    if(information != null && information != "") {
      args.add("information");
      args.add(information);
    }
    if(stackTraceElements != null){
      for (Map<String, String> stackTraceElement in stackTraceElements) {
        stackTraceElement.forEach((k, v){
          args.add(k.toString());
          args.add(v.toString());
        });
      }
    }
    Countly.log(args.toString());
    final String result = await _channel.invokeMethod('logException', <String, dynamic>{
      'data': json.encode(args)
    });
    Countly.log(result);
    return result;
  }

  /// Submits report of a non-fatal error caught by the Flutter framework.
  /// to Countly.
  Future<void> recordFlutterError(FlutterErrorDetails details) async {
    Countly.log('Flutter error caught by Countly:');
    if(!enableCrashReportingFlag) {
      Countly.log('recordFlutterError, Crash Reporting must be enabled to report crash on Countly',logLevel: LogLevel.WARNING);
      return;
    }
    // Since multiple errors can be caught during a single session, we set
    // forceReport=true.
    if(Countly.isDebug) {
      FlutterError.dumpErrorToConsole(details, forceReport: true);
    }
    Countly.isInitialized().then((bool isInitialized){
      if(isInitialized) {
        _internalRecordError(details.exceptionAsString(), details.stack,
            context: details.context,
            information: details.informationCollector == null
                ? null
                : details.informationCollector(),
            printDetails: false);
      }
      else {
        Countly.log('recordFlutterError, countly is not initialized', logLevel: LogLevel.WARNING);
      }

    });
  }

  /// Submits a report of a non-fatal error.
  ///
  /// For errors generated by the Flutter framework, use [recordFlutterError] instead.
  Future<void> recordError(dynamic exception, StackTrace stack,
      {dynamic context}) async {
    Countly.log('Error caught by CountlyCrashReporter <recordError>:');
    if(!enableCrashReportingFlag) {
      Countly.log('recordError, Crash Reporting must be enabled to report crash on Countly',logLevel: LogLevel.WARNING);
      return;
    }
    Countly.isInitialized().then((bool isInitialized){
      if(isInitialized) {
        _internalRecordError(exception, stack, context: context);
      }
      else {
        Countly.log('recordError, countly is not initialized',logLevel: LogLevel.WARNING);
      }

    });
  }

  @visibleForTesting
  List<Map<String, String>> getStackTraceElements(List<String> lines) {
    final List<Map<String, String>> elements = <Map<String, String>>[];
    for (String line in lines) {
      final List<String> lineParts = line.split(RegExp('\\s+'));
      try {
        final String fileName = lineParts[0];
        final String lineNumber = lineParts[1].contains(":")
            ? lineParts[1].substring(0, lineParts[1].indexOf(":")).trim()
            : lineParts[1];

        final Map<String, String> element = <String, String>{
          'file': fileName,
          'line': lineNumber,
        };

        // The next section would throw an exception in some cases if there was no stop here.
        if (lineParts.length < 3) {
          elements.add(element);
          continue;
        }

        if (lineParts[2].contains(".")) {
          final String className =
          lineParts[2].substring(0, lineParts[2].indexOf(".")).trim();
          final String methodName =
          lineParts[2].substring(lineParts[2].indexOf(".") + 1).trim();

          element['class'] = className;
          element['method'] = methodName;
        } else {
          element['method'] = lineParts[2];
        }

        elements.add(element);
      } catch (e) {
        Countly.log(e.toString());
      }
    }
    return elements;
  }

  // On top of the default exception components, [information] can be passed as well.
  // This allows the developer to get a better understanding of exceptions thrown
  // by the Flutter framework. [FlutterErrorDetails] often explain why an exception
  // occurred and give useful background information in [FlutterErrorDetails.informationCollector].
  // Countly will log this information in addition to the stack trace.
  // If [information] is `null` or empty, it will be ignored.
  Future<void> _internalRecordError(
      dynamic exception,
      StackTrace stack, {
        dynamic context,
        Iterable<DiagnosticsNode> information,
        bool printDetails,
      }) async {
    bool inDebugMode = false;
    if (!enableInDevMode) {
      assert(inDebugMode = true);
    }

    printDetails ??= inDebugMode;

    final String _information = (information == null || information.isEmpty)
        ? ''
        : (StringBuffer()..writeAll(information, '\n')).toString();

    if (printDetails) {
      // If available, give context to the exception.
      if (context != null)
        Countly.log('The following exception was thrown $context:');

      // Need to print the exception to explain why the exception was thrown.
      Countly.log(exception);

      // Print information provided by the Flutter framework about the exception.
      if (_information.isNotEmpty) Countly.log('\n$_information');

      // Not using Trace.format here to stick to the default stack trace format
      // that Flutter developers are used to seeing.
      if (stack != null) Countly.log('\n$stack');
    }
    if (!inDebugMode || enableInDevMode) {
      // The stack trace can be null. To avoid the following exception:
      // Invalid argument(s): Cannot create a Trace from null.
      // We can check for null and provide an empty stack trace.
      stack ??= StackTrace.current ?? StackTrace.fromString('');

      // Report error.
      final List<String> stackTraceLines =
      Trace.format(stack).trimRight().split('\n');
      final List<Map<String, String>> stackTraceElements =
      getStackTraceElements(stackTraceLines);
      try {
        logException(exception.toString(), true, stackTraceElements, _information);
      } catch (e) {
        Countly.log('Sending crash report to Countly failed: $e');
      } 

    }
  }
}